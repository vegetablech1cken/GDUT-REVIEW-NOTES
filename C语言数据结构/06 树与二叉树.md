# 6.1 树的定义与基本术语
## 1. 树的基本概念
树是n（n≥0）个结点的有限集合T，当n=0时，称为空树；当n>0时，满足下列条件：   
1. 有且仅有一个特定的结点称为树的根结点，它没有直接前驱结点，但有零个或多个直接后继结点。 
2. 除根结点外，其余结点可分为m（m>=0）个互不相交的有限集合T1，T2，…，Tm，其中每个集合Ti（1≤i≤m）本身又是一棵树，称为根结点的子树。每棵子树的根结点是该结点的直接后继结点。
## 2. 树的图解表示法
1. 倒置树形表示法：将树的根结点画在最上面，子结点画在根结点下面，结点之间用线段连接，表示结点之间的双亲-孩子关系。如图6.1所示。
![](assets/6.1.png)
2. 文氏图表示法：用圆圈表示结点，圆圈内写上结点的值，用线段连接表示结点之间的双亲-孩子关系。如图6.2所示。
![](assets/6.2.png)
3. 广义表表示法：用括号表示树的层次结构，括号内的元素表示结点的值，逗号分隔表示结点之间的双亲-孩子关系。
4. 凹入式表示法：将树的结点按层次结构排列，每一层的结点向右缩进一定的距离，表示结点之间的双亲-孩子关系。如图6.3所示。
![](assets/6.3.png)
## 3. 树的基本术语
1. 结点：树中的每个元素称为结点。结点包含数据域和指针域，数据域存储结点的值，指针域存储指向其子结点的指针。
2. 结点的度：结点的度是指该结点的直接子结点的个数。
3. 叶结点：度为0的结点称为叶结点或终端结点。
4. 分支结点：度大于0的结点称为分支结点或非终端结点。
5. 结点的层次：结点的层次是指从根结点到该结点所经过的边的数目。根结点的层次为0，其子结点的层次为1，依此类推。
6. 结点的层序编号：从上到下、从左到右依次给树的结点编号，称为结点的层序编号。
7. 树的度：树的度是指树中所有结点的最大度。
8. 树的高度（深度）：树的高度是指树中结点的最大层次。
9. 有序树：如果树中每个结点的子结点之间有一个固定的顺序关系，则称该树为有序树。
10. 森林：由m（m≥0）棵互不相交的树组成的集合称为森林。
11. 同构树：如果两棵树的结构相同，即它们的结点之间存在一一对应关系，并且对应结点的度相同，则称这两棵树是同构树。
同时我们也采用人类家族树的术语，以便于直观理解结点间的层次关系
12. 孩子结点：某结点的直接后继结点称为该结点的孩子结点。
13. 双亲结点：某结点的直接前驱结点称为该结点的双亲结点。
14. 兄弟结点：具有同一双亲结点的结点互称为兄弟结点。
15. 堂兄弟结点：具有同一祖父结点但不同双亲结点的结点互称为堂兄弟结点。
16. 祖先结点：从根结点到某结点路径上的所有结点（不包括该结点本身）称为该结点的祖先结点。
17. 子孙结点：以某结点为根结点的子树中的所有结点（不包括该结点本身）称为该结点的子孙结点。
18. 前辈：某结点的祖先结点称为该结点的前辈。
19. 后辈：某结点的子孙结点称为该结点的后辈。
![](assets/6.4.png)
## 4. 树的抽象数据类型（ADT Tree）
树的抽象数据类型定义了树的数据结构及其基本操作。以下是树的抽象数据类型的定义：

```
ADT Tree {
    // 数据对象
    数据对象：一棵由结点组成的树T，其中每个结点包含数据域和指针域。

    // 基本操作
    操作：
        InitTree()：初始化一棵空树T。
        CreateTree()：创建一棵空树T。
        IsEmpty(T)：判断树T是否为空。
        Root(T)：返回树T的根结点。
        Parent(T, e)：返回结点e的双亲结点。
        Children(T, e)：返回结点e的所有孩子结点。
        NextSibling(T, e)：返回结点e的下一个兄弟结点。
        Degree(T, e)：返回结点e的度。
        Height(T)：返回树T的高度。
        InsertChild(T, p, e)：在结点p下插入一个新的孩子结点e。
        DeleteChild(T, p, i)：删除结点p的第i个孩子结点及其子树。
        Traverse(T)：遍历树T的所有结点。
}
```
## 6.2 二叉树
> 任何树都可以转化为二叉树进行处理，二叉树作为特殊的树，适合于计
算机处理

## 6.2.1 二叉树的定义与基本操作
**定义**：把满足下列条件的树称为二叉树（Binary Tree）：  
1. 每个结点最多有两个子结点，分别称为左子结点和右子结点（每个结点的度最多为2）。
2. 左子结点和右子结点有一个先后次序，左子结点在前，右子结点在后（每个结点的子结点顺序固定，不可颠倒）。
由此定义可看出，一个二叉树中的每个结点只能含有0、1 或2 个孩子，而且每个孩子有左右之分，位于左边的孩子称为**左孩子**，位于右边的孩子称为**右孩子**
![](assets/6.5.png)
与树的基本操作类似，二叉树也有一些特定的基本操作：
1. InitBiTree()：初始化一棵空二叉树。   
2. CreateBiTree()：创建一棵空二叉树。  
3. IsEmpty(T)：判断二叉树T是否为空。
4. DestroyBiTree(T)：销毁二叉树T，释放其占用的存储空间。
5. Root(T)：返回二叉树T的根结点。
6. Parent(T, e)：返回结点e的双亲结点。
7. LeftChild(T, e)：返回结点e的左孩子结点。
8. RightChild(T, e)：返回结点e的右孩子结点。
9. Traverse(T)：遍历二叉树T的所有结点。
10. ClearBiTree(T)：清空二叉树T，使其成为一棵空树。
## 6.2.2 二叉树的性质
- 性质1：在二叉树的第i层上，最多有$2^{i-1}$个结点（i≥1）。
证明：  
对于i=1（即根结点所在层），最多有$2^{1-1}=2^0=1$个结点，成立。  
假设对于第k层，最多有$2^{k-1}$个结点成立。  
则对于第k+1层，每个结点最多有2个孩子，因此第k+1层最多有$2 \times 2^{k-1} = 2^k$个结点。  
因此，性质1成立。
- 性质2：深度为k的二叉树最多有$2^k-1$个结点（k≥1）。
证明：
根据性质1，二叉树的每一层最多有$2^{i-1}$个结点，因此深度为k的二叉树的最大结点数为：
$N = 2^0 + 2^1 + 2^2 + ... + 2^{k-1} = 2^k - 1$
因此，性质2成立。
- 性质3：对于任意一棵二叉树T，设其叶结点数为n0，度为2的结点数为n2，则有$n0 = n2 + 1$。
证明：
设二叉树T的总结点数为n，则有：
$n = n0 + n1 + n2$
其中n1为度为1的结点数。
根据二叉树的性质，每个结点都有一个双亲结点（根结点除外），因此有：
$n - 1 = n1 + 2n2$
将上述两个方程联立，得到：
$n0 + n1 + n2 - 1 = n1 + 2n2$
化简后得到：
$n0 - 1 = n2$
因此，性质3成立。
下面先给出两种特殊的二叉树定义：
1. 满二叉树：如果一棵二叉树的所有叶结点都在同一层上，且每个非叶结点的度都为2，则称该二叉树为满二叉树（Full Binary Tree）。
2. 完全二叉树：如果一棵二叉树的每一层（除最后一层外）都被完全填满，并且最后一层的叶结点都集中在该层的左侧，则称该二叉树为完全二叉树（Complete Binary Tree）。
![](assets/6.6.png)
- 性质4：具有n个结点的完全二叉树的高度为$⌊log_2 n⌋ + 1$。
证明：
假设n个结点的完全二叉树的高度为h，则根据完全二叉树的定义，前h-1层都是满的，因此前h-1层的结点数为：
$N_{h-1} = 2^0 + 2^1 + 2^2 + ... + 2^{h-2} = 2^{h-1} - 1$
最后一层的结点数最多（满二叉树）为$2^{h-1}$，因此有：
$n ≤ N_{h-1} + 2^{h-1} = 2^h - 1$
显然有：
$2^{h-1}  -1 < n ≤ 2^{h}-1$
则
$2^{h-1} \leq n < 2^{h}$
解得：
$h ≥ ⌊log_2 n⌋ + 1$
另一方面，完全二叉树的高度h也不能超过$⌊log_2 n⌋ + 1$，否则结点数将超过n。因此，性质4成立。
- 性质5：对于具有n个结点的完全二叉树，如果按照从上到下和从左到右的顺序对二叉树中的所有结点从 1 开始顺序编号，则对于任意的序号为 i 的结点有：
  1. 若i=1，则该结点为根结点；
  2. 若i>1，则该结点的双亲结点的序号为$⌊i/2⌋$；
  3. 若2i≤n，则该结点的左孩子结点的序号为2i；
  4. 若2i+1≤n，则该结点的右孩子结点的序号为2i+1。
## 6.2.3 二叉树的存储结构
二叉树的结构是非线性的，因此在计算机中存储二叉树时，通常采用链式存储结构或顺序存储结构。
### 1. 顺序存储结构
顺序存储结构是将二叉树的结点按层序依次存储在一维数组中，其中根结点存储在数组的第一个位置（下标为0），对于任意一个结点，其左孩子结点存储在数组的下标为2i+1的位置，右孩子结点存储在数组的下标为2i+2的位置（i为该结点在数组中的下标）。如图6.7所示。
![](assets/6.7.png)
这种存储结构的优点是访问结点时可以通过数组下标直接定位，缺点是当二叉树不完全时会浪费存储空间。如图6.8所示。
![](assets/6.8.png)
### 2. 链式存储结构
对任意一个二叉树T，其每个结点由一个数据域和两个指针域组成，分别指向该结点的左孩子结点和右孩子结点。如果某个孩子结点不存在，则相应的指针域为空（NULL）。如图6.9所示。
![](assets/6.9.png)
其中，LChild指向左孩子结点，RChild指向右孩子结点，Data存储结点的数据。此结点结构形成的二叉树称为二叉链表（Binary Linked List）。
![](assets/6.10.png)
二叉链表的优点是存储空间利用率高，适合于动态变化的二叉树结构，缺点是访问结点时需要通过指针进行遍历，效率较低。
用c语言描述二叉链表结点的数据结构如下：
```c
typedef struct BiTNode {
    ElemType data;                  // 结点数据域
    struct BiTNode *LChild;        // 指向左孩子结点的指针
    struct BiTNode *RChild;        // 指向右孩子结点的指针
} BiTNode, *BiTree;
```
若一个二叉树含有n个结点，则其二叉链表结构需要n个BiTNode类型的结点，每个结点占用的存储空间为$sizeof(ElemType) + 2*sizeof(BiTNode*)$，因此整个二叉链表所需的存储空间为$n * (sizeof(ElemType) + 2*sizeof(BiTNode*))$。
# 6.3 二叉树的遍历和线索化
> 二叉树的遍历是指按照一定的顺序访问二叉树中的每个结点。其中访问可指计算二叉树中结点的数据信息，打印结点的值，或对结点进行其他操作。常见的二叉树遍历方式有三种：前序遍历、中序遍历和后序遍历。此外，还有一种特殊的遍历方式称为层序遍历。

## 6.3.1 二叉树的遍历
如果用L,D,R分别表示访问左子树、访问根结点和访问右子树，则共有六种不同的遍历方式：
1. 前序遍历（Preorder Traversal）：D L R
2. 中序遍历（Inorder Traversal）：L D R
3. 后序遍历（Postorder Traversal）：L R D
4. 根-右-左遍历（Root-Right-Left Traversal）：D R L
5. 右-根-左遍历（Right-Root-Left Traversal）：R D L
6. 右-左-根遍历（Right-Left-Root Traversal）：R L D
![](assets/6.11.png)
其中，前序遍历、中序遍历和后序遍历是最常用的三种遍历方式。下面分别介绍这三种遍历方式的递归实现
### 1. 先序遍历
若二叉树为空，则结束遍历；否则
1. 访问根结点；
2. 递归地对左子树进行先序遍历；
3. 递归地对右子树进行先序遍历。
其递归算法如下：
```c
void PreOrder(BiTree T) {
    if (T != NULL) {
        Visit(T);               // 访问根结点
        PreOrder(T->LChild);   // 递归遍历左子树
        PreOrder(T->RChild);   // 递归遍历右子树
    }
}
```
### 2. 中序遍历
若二叉树为空，则结束遍历；否则
1. 递归地对左子树进行中序遍历；
2. 访问根结点；
3. 递归地对右子树进行中序遍历。
其递归算法如下：
```c
void InOrder(BiTree T) {
    if (T != NULL) {
        InOrder(T->LChild);    // 递归遍历左子树
        Visit(T);               // 访问根结点
        InOrder(T->RChild);    // 递归遍历右子树
    }
}
```
### 3. 后序遍历
若二叉树为空，则结束遍历；否则
1. 递归地对左子树进行后序遍历；
2. 递归地对右子树进行后序遍历；
3. 访问根结点。
其递归算法如下：
```c
void PostOrder(BiTree T) {
    if (T != NULL) {
        PostOrder(T->LChild);   // 递归遍历左子树
        PostOrder(T->RChild);   // 递归遍历右子树
        Visit(T);               // 访问根结点
    }
}
```
显然这三种算法的区别表现在Visit(T)的位置不同，但都采用了递归的方法
![](assets/6.14.png)
**递归算法的时间复杂度**：设二叉树T有n个结点，则每个结点被访问一次，递归调用的次数与结点数成正比，因此递归算法的时间复杂度为O(n)。
**递归算法的空间复杂度**：递归调用时需要使用栈空间来保存函数调用的信息，栈空间的最大深度与二叉树的高度h有关，因此递归算法的空间复杂度为O(h)。
## 6.2.3 遍历算法应用
### 1. 输出二叉树中的结点
在遍历二叉树的过程中，可以将每个结点的值输出到控制台或存储到数组中。例如，在前序遍历中，可以在Visit(T)函数中实现输出操作：
```c
void Visit(BiTree T) {
    printf("%d ", T->data); // 输出结点的值
}
```
### 2. 输出二叉树中的叶子结点
在遍历二叉树的过程中，可以判断每个结点是否为叶子结点（即度为0的结点），如果是，则输出该结点的值。例如，在中序遍历中，可以在Visit(T)函数中实现叶子结点的输出操作：
```c
void Visit(BiTree T) {
    if (T->LChild == NULL && T->RChild == NULL) {
        printf("%d ", T->data); // 输出叶子结点的值
    }
}
```
### 3. 统计叶子结点的个数
在遍历二叉树的过程中，可以使用一个全局变量或传递一个指针来统计叶子结点的个数。
方法一：在后序遍历中，可以在Visit(T)函数中实现叶子结点计数操作：
```c
int leafCount = 0; // 全局变量统计叶子结点个数
void Visit(BiTree T) {
    if (T->LChild == NULL && T->RChild == NULL) {
        leafCount++; // 叶子结点计数
    }
}
```
方法二：采用分治法，在递归函数中返回叶子结点的个数：
```c
int CountLeaves(BiTree T) {
    if (T == NULL) {
        return 0; // 空树叶子结点个数为0
    }
    if (T->LChild == NULL && T->RChild == NULL) {
        return 1; // 叶子结点个数为1
    }
    return CountLeaves(T->LChild) + CountLeaves(T->RChild); // 递归统计左右子树的叶子结点个数
}
```
### 4. 建立二叉链表方式存储的二叉树
在建立二叉链表方式存储的二叉树时，可以采用递归的方法，根据输入的数据构建二叉树的结构。例如，可以通过前序遍历的方式输入结点的值，使用特殊符号（如'#'）表示空结点。以下是一个示例代码：
```c
BiTree CreateBiTree() {
    char ch;
    scanf("%c", &ch);
    if (ch == '#') {
        return NULL; // 空结点
    } else {
        BiTree T = (BiTree)malloc(sizeof(BiTNode));
        T->data = ch; // 结点赋值
        T->LChild = CreateBiTree(); // 递归创建左子树
        T->RChild = CreateBiTree(); // 递归创建右子树
        return T;
    }
}
```
### 5. 计算二叉树的高度
在遍历二叉树的过程中，可以使用递归的方法计算二叉树的高度。例如，可以在递归函数中返回二叉树的高度：
```c
int BiTreeHeight(BiTree T) {
    if (T == NULL) {
        return 0; // 空树高度为0
    }
    int leftHeight = BiTreeHeight(T->LChild); // 计算左子树高度
    int rightHeight = BiTreeHeight(T->RChild); // 计算右子树高度
    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1; // 返回较大高度加1
}
```
![](assets/6.16.png)
### 6. 按树状图格式输出二叉树
在遍历二叉树的过程中，可以采用递归的方法按树状图格式输出二叉树。例如，可以在递归函数中传递当前结点的层次信息，并根据层次信息输出相应的缩进：
```c
void PrintTree(BiTree T, int level) {
    if (T == NULL) {
        return; // 空结点
    }
    PrintTree(T->RChild, level + 1); // 递归打印右子树
    for (int i = 0; i < level; i++) {
        printf("    "); // 输出缩进
    }
    printf("%c\n", T->data); // 输出结点值
    PrintTree(T->LChild, level + 1); // 递归打印左子树
}
```
## 6.3.3 基于栈的递归消除
工作栈是一种辅助数据结构，用于模拟递归调用过程中的函数调用栈，从而实现递归算法的非递归版本。
### 1. 中序遍历二叉树的非递归实现
思路：
1. 初始化一个空栈S和一个指向当前结点的指针p，初始时p指向二叉树的根结点T。
2. 当p不为空或栈S不为空时，重复以下步骤：
   a. 如果p不为空，则将p入栈，并将p指向其左子结点。
   b. 如果p为空，则从栈S中弹出一个结点，将其赋值给p，访问该结点，然后将p指向其右子结点。
```c
void InOrderNonRecursive(BiTree T) {
    Stack S;               // 定义工作栈
    InitStack(&S);        // 初始化栈
    BiTree p = T;         // 指向当前结点的指针

    while (p != NULL || !IsStackEmpty(&S)) {
        while (p != NULL) {
            Push(&S, p);  // 将当前结点入栈
            p = p->LChild; // 移动到左子结点
        }
        if (!IsStackEmpty(&S)) {
            Pop(&S, &p);   // 弹出栈顶结点
            Visit(p);      // 访问结点
            p = p->RChild; // 移动到右子结点
        }
    }
}
```
![](assets/6.18.png)
中序遍历需要设置一个工作栈来保存结点指针，以便在访问完左子树后能够返回到根结点并继续访问右子树。
**递归算法的时间复杂度分析**：设二叉树T有n个结点，则每个结点被访问一次，非递归算法的时间复杂度为O(n)。
**递归算法的空间复杂度分析**：在最坏情况下，工作栈中可能存储二叉树的所有结点，因此空间复杂度为O(h)，其中h为二叉树的高度。
### 2. 后序遍历二叉树的非递归实现
思路：
1. 初始化一个空栈S和一个指向当前结点的指针p，初始时p指向二叉树的根结点T。同时，定义一个指针pre，初始时为NULL，用于记录上一个访问的结点。
2. 当p不为空或栈S不为空时，重复以下步骤：
   a. 如果p不为空，则将p入栈，并将p指向其左子结点。
   b. 如果p为空，则查看栈顶结点top：
      i. 如果top的右子结点不为空且未被访问过，则将p指向top的右子结点。
      ii. 否则，弹出栈顶结点top，访问该结点，并将pre指向top。
```c
void PostOrderNonRecursive(BiTree T) {
    Stack S;               // 定义工作栈
    InitStack(&S);        // 初始化栈
    BiTree p = T;         // 指向当前结点的指针
    BiTree pre = NULL;    // 记录上一个访问的结点

    while (p != NULL || !IsStackEmpty(&S)) {
        while (p != NULL) {
            Push(&S, p);  // 将当前结点入栈
            p = p->LChild; // 移动到左子结点
        }
        BiTree top;
        Peek(&S, &top);   // 查看栈顶结点
        if (top->RChild != NULL && pre != top->RChild) {
            p = top->RChild; // 移动到右子结点
        } else {
            Pop(&S, &top);   // 弹出栈顶结点
            Visit(top);      // 访问结点
            pre = top;       // 更新上一个访问的结点
        }
    }
}
```
### 6.3.4 线索二叉树    
#### 1. 基本概念
在二叉树的链式存储结构中，结点的指针域通常用于存储指向其左孩子和右孩子的指针。然而，在某些情况下，结点的某些指针域可能为空（NULL），这会导致存储空间的浪费。为了解决这个问题，引入了线索二叉树的概念。
线索二叉树（Threaded Binary Tree）是一种特殊的二叉树，其中结点的空指针域被用来存储指向其前驱结点或后继结点的指针，从而形成一种线索结构。这样，在遍历二叉树时，可以利用这些线索来快速找到前驱或后继结点，而无需进行递归或使用栈。
![](assets/6.19.png)
在这种存储结构中，除了数据域和左右孩子指针外，还增加了两个标志位LTag和RTag，用于指示指针域的类型：
- LTag：如果LTag=0，表示LChild指向左孩子结点；如果LTag=1，表示LChild指向前驱结点。
- RTag：如果RTag=0，表示RChild指向右孩子结点；如果RTag=1，表示RChild指向后继结点。
将指向前驱和后驱结点的指针称为线索（Thread），以这种结构组成的二叉链表称为线索链表（Threaded Linked List），对二叉树以某种次序进行遍历并建立线索链表的过程称为线索化（Threading），线索化了的二叉树称为线索二叉树。
#### 2. 线索化的实现
以中序线索化为例，线索化的过程可以通过递归实现
```c
BiTree pre = NULL; // 全局变量，记录前驱结点
void InOrderThreading(BiTree T) {
    if (T != NULL) {
        InOrderThreading(T->LChild); // 递归线索化左子树

        // 处理当前结点
        if (T->LChild == NULL) {
            T->LTag = 1;          // 设置左线索标志
            T->LChild = pre;      // 指向前驱结点
        }
        if (pre != NULL && pre->RChild == NULL) {
            pre->RTag = 1;        // 设置右线索标志
            pre->RChild = T;      // 指向后继结点
        }
        pre = T;                   // 更新前驱结点

        InOrderThreading(T->RChild); // 递归线索化右子树
    }
}
```
对同一棵二叉树，经过不同次序的线索化，可以得到不同类型的线索二叉树，如前序线索二叉树和后序线索二叉树。
![](assets/6.20.png)
#### 3. 在线索二叉树中找前驱和后继结点
在线索二叉树中，利用线索可以快速找到结点的前驱和后继结点。
- 找前驱结点：
```c
BiTree InOrderPredecessor(BiTree p) {
    if (p->LTag == 1) {
        return p->LChild; // 左线索指向前驱结点
    } else {
        BiTree q = p->LChild;
        while (q->RTag == 0) {
            q = q->RChild; // 找到最右的结点
        }
        return q;
    }
}
```
- 找后继结点：
```c
BiTree InOrderSuccessor(BiTree p) {
    if (p->RTag == 1) {
        return p->RChild; // 右线索指向后继结点
    } else {
        BiTree q = p->RChild;
        while (q->LTag == 0) {
            q = q->LChild; // 找到最左的结点
        }
        return q;
    }
}
```
#### 4. 线索二叉树的遍历
在线索二叉树中，可以利用线索进行高效的遍历。例如，中序遍历线索二叉树的算法如下：
```c
void InOrderTraverseThreaded(BiTree T) {
    BiTree p = T;
    // 找到最左的结点
    while (p->LTag == 0) {
        p = p->LChild;
    }
    while (p != NULL) {
        Visit(p); // 访问结点
        // 找到后继结点
        if (p->RTag == 1) {
            p = p->RChild; // 右线索指向后继结点
        } else {
            p = p->RChild;
            while (p != NULL && p->LTag == 0) {
                p = p->LChild; // 找到最左的结点
            }
        }
    }
}
```
### 6.3.5 由遍历序列确定二叉树
在已知二叉树的某两种遍历序列的情况下，可以唯一确定一棵二叉树。常见的组合有：
1. 前序遍历序列和中序遍历序列
2. 后序遍历序列和中序遍历序列
下面以前序遍历序列和中序遍历序列为例，介绍如何构建二叉树。
假设已知二叉树的前序遍历序列为Pre[]，中序遍历序列为In[]，则可以通过以下步骤构建二叉树：
1. 从前序遍历序列中取出第一个元素作为根结点的值rootValue。
2. 在中序遍历序列中找到rootValue的位置index，将中序遍历序列分为左子树的中序遍历序列In[0..index-1]和右子树的中序遍历序列In[index+1..n-1]。
3. 根据左子树的中序遍历序列的长度leftSize，确定左子树的前序遍历序列Pre[1..leftSize]和右子树的前序遍历序列Pre[leftSize+1..n-1]。
4. 递归地构建左子树和右子树。
```c
BiTree BuildTree(char Pre[], char In[], int preStart, int preEnd, int inStart, int inEnd) {
    if (preStart > preEnd || inStart > inEnd) {
        return NULL; // 递归终止条件
    }
    char rootValue = Pre[preStart]; // 根结点值
    BiTree root = (BiTree)malloc(sizeof(BiTNode));
    root->data = rootValue;

    // 在中序遍历序列中找到根结点位置
    int index;
    for (index = inStart; index <= inEnd; index++) {
        if (In[index] == rootValue) {
            break;
        }
    }
    int leftSize = index - inStart; // 左子树结点数

    // 递归构建左子树和右子树
    root->LChild = BuildTree(Pre, In, preStart + 1, preStart + leftSize, inStart, index - 1);
    root->RChild = BuildTree(Pre, In, preStart + leftSize + 1, preEnd, index + 1, inEnd);

    return root;
}
```
![](assets/6.23.png)
# 6.4 树、森林和二叉树的关系
## 6.4.1 树的存储结构
树的存储结构主要有三种：双亲表示法、孩子表示法和孩子-兄弟表示法。
### 1. 双亲表示法
双亲表示法是用一个一维数组来存储树的结点信息，其中每个结点包含数据域和一个指向其双亲结点的指针域。数组的下标表示结点的层序编号。对于根结点，其双亲指针域为空（NULL）。如图6.24所示。
![](assets/6.24.png)
其结点结构定义如下：
```c
typedef struct PTNode {
    ElemType data;          // 结点数据域
    int parent;             // 指向双亲结点的下标
} PTNode;
typedef struct {
    PTNode nodes[MAX_SIZE]; // 结点数组
    int n;                  // 结点数
} PTree;
```
### 2. 孩子表示法
孩子表示法是用一个一维数组来存储树的结点信息，其中每个结点包含数据域和一个指向其第一个孩子结点的指针域。每个结点的其他孩子结点通过链表连接起来。对于叶结点，其孩子指针域为空（NULL）。如图6.26所示。
![](assets/6.26.png)
其结点结构定义如下：
```c
typedef struct CTNode {
    ElemType data;              // 结点数据域
    struct ChildNode *firstChild; // 指向第一个孩子结点的指针
} CTNode;
typedef struct ChildNode {
    int childIndex;             // 孩子结点在数组中的下标
    struct ChildNode *next;     // 指向下一个孩子结点的指针
} ChildNode;
typedef struct {
    CTNode nodes[MAX_SIZE];     // 结点数组
    int n;                      // 结点数
} CTree;
```
### 3. 孩子-兄弟表示法
孩子-兄弟表示法是将树转化为二叉树进行存储的一种方法。每个结点包含数据域、一个指向其第一个孩子结点的指针域和一个指向其下一个兄弟结点的指针域。对于没有孩子或兄弟的结点，相应的指针域为空（NULL）。如图6.27所示。
![](assets/6.27.png)
其结点结构定义如下：
```c
typedef struct CSNode {
    ElemType data;              // 结点数据域
    struct CSNode *firstChild;  // 指向第一个孩子结点的指针
    struct CSNode *nextSibling; // 指向下一个兄弟结点的指针
} CSNode, *CSTree;
```
## 6.4.2 树、森林与二叉树的转换
树与森林之间可以相互转换。将一棵树的每个结点的孩子结点按顺序连接成一个链表，形成一个森林；反之，将森林中的每棵树的根结点作为一个新的结点的孩子结点，形成一棵树。
### 1. 树转二叉树
将树转化为二叉树的过程如下：
1. 对于树中的每个结点，将其第一个孩子结点作为该结点的左孩子结点。
2. 对于每个结点的其他孩子结点，将它们依次作为该结点的右兄弟结点。
3. 重复上述过程，直到所有结点都被处理完毕。
![](assets/6.28.png)
### 2. 森林转二叉树
将森林转化为二叉树的过程如下：
1. 创建一个新的根结点，将森林中的每棵树的根结点作为该根结点的孩子结点。
2. 对于每棵树，按照树转二叉树的方法进行转换。
3. 重复上述过程，直到所有树都被处理完毕。
![](assets/6.30.png)
其递归算法如下：
```c
CSTree ForestToBinaryTree(CTree F) {
    if (F.n == 0) {
        return NULL; // 空森林
    }
    CSTree root = (CSTree)malloc(sizeof(CSNode));
    root->data = 'F'; // 新建根结点
    root->firstChild = NULL;
    root->nextSibling = NULL;

    CSNode *prev = NULL; // 记录上一个孩子结点
    for (int i = 0; i < F.n; i++) {
        CSTree tree = TreeToBinaryTree(&F.nodes[i]); // 转换每棵树
        if (prev == NULL) {
            root->firstChild = tree; // 第一个孩子结点
        } else {
            prev->nextSibling = tree; // 连接兄弟结点
        }
        prev = tree; // 更新上一个孩子结点
    }
    return root;
}
```
### 3. 二叉树还原为树、森林
将二叉树还原为树或森林的过程如下：
1. 对于二叉树中的每个结点，将其左孩子结点作为该结点的第一个孩子结点。
2. 对于每个结点的右兄弟结点，将它们依次作为该结点的其他孩子结点。
3. 重复上述过程，直到所有结点都被处理完毕。
![](assets/6.32.png)
采用递归算法如下：
```c
CTree BinaryTreeToForest(CSTree T) {
    CTree F;
    F.n = 0;
    if (T == NULL) {
        return F; // 空二叉树
    }
    // 处理当前结点
    CTNode node;
    node.data = T->data;
    node.firstChild = NULL;

    // 处理左孩子结点
    if (T->firstChild != NULL) {
        CSTree child = T->firstChild;
        CTNode *prevChild = NULL; // 记录上一个孩子结点
        while (child != NULL) {
            CTree subForest = BinaryTreeToForest(child); // 递归还原子树
            if (prevChild == NULL) {
                node.firstChild = &subForest.nodes[0]; // 第一个孩子结点
            } else {
                prevChild->nextSibling = &subForest.nodes[0]; // 连接兄弟结点
            }
            prevChild = &subForest.nodes[0]; // 更新上一个孩子结点
            child = child->nextSibling; // 移动到下一个兄弟结点
        }
    }
    F.nodes[F.n++] = node; // 添加当前结点到森林
    return F;
}
```
## 6.4.3 树与森林的遍历
树与森林的遍历方法与二叉树类似，可以采用递归或非递归的方法进行遍历。以下以前序遍历为例，介绍树与森林的遍历方法。
### 1. 树的遍历
树的遍历主要有两种方式：先根遍历和后根遍历。
- 先根遍历（Preorder Traversal）：访问根结点，然后依次遍历每个子树。
- 后根遍历（Postorder Traversal）：依次遍历每个子树，然后访问根结点。
### 2. 树的遍历算法实现
在选定了存储结构后，可以实现树的遍历算法。以下以孩子-兄弟表示法为例，给出树的先根遍历和后根遍历的递归实现。
- 先根遍历
```c
void PreOrderTree(CSTree T) {
    if (T != NULL) {
        Visit(T); // 访问根结点
        CSTree child = T->firstChild;
        while (child != NULL) {
            PreOrderTree(child); // 递归遍历子树
            child = child->nextSibling; // 移动到下一个兄弟结点
        }
    }
}
```
- 后根遍历
```c
void PostOrderTree(CSTree T) {
    if (T != NULL) {
        CSTree child = T->firstChild;
        while (child != NULL) {
            PostOrderTree(child); // 递归遍历子树
            child = child->nextSibling; // 移动到下一个兄弟结点
        }
        Visit(T); // 访问根结点
    }
}
```
### 3. 森林的遍历
森林的遍历可以看作是对森林中每棵树的遍历。以下以孩子-兄弟表示法为例，给出森林的先根遍历和后根遍历的递归实现。
- 先根遍历
```c
void PreOrderForest(CSTree F[], int n) {
    for (int i = 0; i < n; i++) {
        PreOrderTree(F[i]); // 遍历每棵树
    }
}
```
- 后根遍历
```c
void PostOrderForest(CSTree F[], int n) {
    for (int i = 0; i < n; i++) {
        PostOrderTree(F[i]); // 遍历每棵树
    }
}
```
# 6.5 哈夫曼树及其应用
## 6.5.1 哈夫曼树
### 1. 基本概念
哈夫曼树（Huffman Tree）是一种带权路径长度最短的二叉树，广泛应用于数据压缩和编码领域。哈夫曼树的构建基于贪心算法，通过不断合并权值最小的结点来形成一棵最优二叉树。
1. 路径和路径长度：在一棵树中，从根结点到某个结点所经过的边的序列称为该结点的路径，路径上边的数量称为该结点的路径长度。
2. 结点的权：结点的权是与该结点相关联的一个数值，通常表示该结点的重要性或频率。
3. 哈夫曼树的带权路径长度（WPL）：哈夫曼树中所有叶子结点的权值与其路径长度的乘积之和，称为带权路径长度。
![](assets/6.33.png)
### 2. 哈夫曼树的构建算法
构建哈夫曼树的过程如下：
1. 初始化：将每个结点作为一棵单结点树，构成一个森林。
2. 重复以下步骤，直到森林中只剩下一棵树为止：
   a. 从森林中选出两棵权值最小的树，设其根结点的权值分别为w1和w2。
   b. 创建一个新的结点，其权值为w1+w2，将这两棵树作为该结点的左子树和右子树。
   c. 将新结点加入森林中，并移除原来的两棵树。
3. 最终剩下的那棵树即为哈夫曼树。

### 3. 哈夫曼树的类型定义
#### 存储结构
哈夫曼树通常采用二叉链表存储结构，由于哈夫曼树中没有度为1的结点，因此可以使用二叉链表来表示哈夫曼树的结点。每个结点包含权值、指向双亲结点、左孩子结点和右孩子结点的指针。构成一个三叉链表结构。
静态三叉链表中，每个结点的结构如图
![](assets/6.37.png)
哈夫曼树的结点结构定义如下：
```c    
typedef struct HTNode {
    int weight;                 // 结点权值
    int parent;                 // 指向双亲结点的下标
    int lchild;                 // 指向左孩子结点的下标
    int rchild;                 // 指向右孩子结点的下标
} HTNode, *HuffmanTree;
```
### 4. 哈夫曼树的算法实现
```c
typedef struct HTNode {
    int weight;                 // 结点权值
    int parent;                 // 指向双亲结点的下标
    int lchild;                 // 指向左孩子结点的下标
    int rchild;                 // 指向右孩子结点的下标
} HTNode, *HuffmanTree;
HuffmanTree CreateHuffmanTree(int weights[], int n) {
    int m = 2 * n - 1; // 哈夫曼树结点总数
    HuffmanTree HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode));
    for (int i = 1; i <= n; i++) {
        HT[i].weight = weights[i - 1];
        HT[i].parent = 0;
        HT[i].lchild = 0;
        HT[i].rchild = 0;
    }
    for (int i = n + 1; i <= m; i++) {
        HT[i].weight = 0;
        HT[i].parent = 0;
        HT[i].lchild = 0;
        HT[i].rchild = 0;
    }
    for (int i = n + 1; i <= m; i++) {
        int s1, s2;
        Select(HT, i - 1, &s1, &s2); // 选择权值最小的两个结点
        HT[s1].parent = i;
        HT[s2].parent = i;
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight; // 更新新结点权值
    }
    return HT;
}
void Select(HuffmanTree HT, int n, int *s1, int *s2) {
    int min1 = INT_MAX, min2 = INT_MAX;
    *s1 = 0;
    *s2 = 0;
    for (int i = 1; i <= n; i++) {
        if (HT[i].parent == 0) { // 只考虑未被选中的结点
            if (HT[i].weight < min1) {
                min2 = min1;
                *s2 = *s1;
                min1 = HT[i].weight;
                *s1 = i;
            } else if (HT[i].weight < min2) {
                min2 = HT[i].weight;
                *s2 = i;
            }
        }
    }
}
```
### 6.5.2 哈夫曼编码
由于哈夫曼树具有带权路径长度最短的性质，因此可以利用哈夫曼树来实现高效的编码方案，即哈夫曼编码（Huffman Coding）。哈夫曼编码是一种可变长度编码方式，常用于数据压缩领域。
### 1. 哈夫曼编码的基本原理
哈夫曼编码的基本原理是根据字符出现的频率（权值）来分配不同长度的二进制编码。出现频率高的字符分配较短的编码，出现频率低的字符分配较长的编码，从而实现整体编码长度的最小化。
在哈夫曼树中，从根结点到每个叶子结点的路径可以表示为该叶子结点对应字符的哈夫曼编码。通常，左子树路径表示为'0'，右子树路径表示为'1'。
### 2. 哈夫曼编码的作用
哈夫曼编码的主要作用包括：
1. 数据压缩：通过减少常用字符的编码长度，实现数据的压缩，节省存储空间和传输带宽。
2. 无损编码：哈夫曼编码是一种无损编码方式，能够确保编码后的数据可以完全还原为原始数据。
3. 提高传输效率：在通信系统中，使用哈夫曼编码可以提高数据传输的效率，减少传输时间。
例：前缀编码的设计
假设有如下字符及其对应的权值：
| 字符 | A | B | C | D | E | F |
|------|---|---|---|---|---|---|
| 权值 | 5 | 9 | 12| 13| 16| 45|
根据哈夫曼编码的原理，可以构建如下哈夫曼树，并得到对应的哈夫曼编码：
| 字符 | A   | B   | C   | D   | E   | F  |
|------|-----|-----|-----|-----|-----|-----|
| 编码 | 1100| 1101| 100 | 101 | 111 | 0   |
### 3. 哈夫曼编码的算法实现
```c    
void GenerateHuffmanCodes(HuffmanTree HT, int n, char codes[][MAX_CODE_LEN]) {
    char code[MAX_CODE_LEN];
    code[MAX_CODE_LEN - 1] = '\0'; // 结束符
    for (int i = 1; i <= n; i++) {
        int start = MAX_CODE_LEN - 1;
        int current = i;
        int parent = HT[current].parent;
        while (parent != 0) {
            if (HT[parent].lchild == current) {
                code[--start] = '0'; // 左子树路径
            } else {
                code[--start] = '1'; // 右子树路径
            }
            current = parent;
            parent = HT[current].parent;
        }
        strcpy(codes[i - 1], &code[start]); // 存储哈夫曼编码
    }
}
```